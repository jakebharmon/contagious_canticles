choices = NULL,
options = list(
create = FALSE,
placeholder = "Search Me"
)
)
),
# Main panel for displaying the plot
mainPanel(
plotOutput("survival_plot")
)
)
)
# Server function
server <- function(input, output, session) {
# Get the unique names of the songs to populate the dropdown
song_choices_df = survival_df %>%
distinct(song_id, Title, PageNum) %>%
mutate(song_title = paste0(PageNum, " - ", Title)) %>%
arrange(song_id)
# The values will be the song_id, names will be the song_title
song_choices = setNames(song_choices_df$song_id, song_choices_df$song_title)
# Update the choices for the dropdown list
# This observe block will run once at startup to populate the choices.
observe({
updateSelectizeInput(
session,
"searchme",
choices = song_choices,
selected = NULL # No default selection for a clean start
)
})
# Reactive expression to filter the data based on user selection
filtered_data = reactive({
req(input$searchme)
# Filter the original data to include only the selected songs
df_filtered <- survival_df %>%
filter(song_id %in% input$searchme) %>%
# Create the 'song' column for the plot's strata
mutate(song = paste0(" ", PageNum, " - ", Title),
song = factor(song))
return(df_filtered)
})
# Generate and render the ggsurvplot
output$survival_plot <- renderPlot({
# Get the filtered data
df = filtered_data()
fit = surv_fit(Surv(time_to_event_days, event_status) ~ song, data = df)
ggsurvplot(
fit,
data = df,
conf.int = TRUE,
risk.table = TRUE,
risk.table.col = "strata",
ggtheme = theme_bw(),
title = "Survival Curve by Song",
palette = "viridis"
)
})
}
# Run the application
shinyApp(ui = ui, server = server)
# Get the filtered data
df = filtered_data()
library(shiny)
library(survival)
library(survminer)
library(viridis)
# Load and prepare the data
data("lung")
lung <- na.omit(lung)
# Give factor levels clear names for the dropdown and plot
lung$sex <- factor(lung$sex, levels = c(1, 2), labels = c("Male", "Female"))
lung$ph.ecog <- factor(lung$ph.ecog, levels = c(0, 1, 2), labels = c("Good", "Moderate", "Poor"))
# Define UI for the application
ui <- fluidPage(
titlePanel("Kaplan-Meier Curves Shaded by Hazard Ratio"),
sidebarLayout(
sidebarPanel(
# Dropdown menu to select the grouping variable
selectInput(
inputId = "group_var",
label = "Select Grouping Variable:",
choices = c(
"Sex" = "sex",
"ECOG Performance Score" = "ph.ecog"
),
selected = "sex" # Default selected variable
),
helpText("The first level of the selected factor will be used as the reference group (HR = 1).",
"Curves are colored by their hazard ratio (HR) relative to this reference.",
"Darker colors represent a higher HR (steeper slope).")
),
mainPanel(
plotOutput("km_plot")
)
)
)
# Define server logic
server <- function(input, output) {
# Reactive expression to run the survival analysis
surv_analysis <- reactive({
# Ensure a grouping variable is selected
req(input$group_var)
# Dynamically create the formula for survfit and coxph
formula_surv <- as.formula(paste("Surv(time, status) ~", input$group_var))
# Create the survfit object
fit <- survfit(formula_surv, data = lung)
# Run the Cox Proportional Hazards model
cox_model <- coxph(formula_surv, data = lung)
# Return both objects
list(fit = fit, cox_model = cox_model)
})
# Reactive expression to handle the plotting
output$km_plot <- renderPlot({
# Get the results from the reactive analysis
analysis_results <- surv_analysis()
fit <- analysis_results$fit
cox_model <- analysis_results$cox_model
# Extract the hazard ratios and group labels dynamically
hr_values <- exp(coef(cox_model))
group_levels <- levels(lung[[input$group_var]])
# Create a data frame for hazard ratios, including the reference group
hr_df <- data.frame(
group = group_levels,
hazard_ratio = c(1.0, hr_values)
)
# Map hazard ratios to a viridis palette
# Order the ratios and create the color map
hr_ordered <- hr_df[order(hr_df$hazard_ratio), ]
viridis_colors <- viridis(n = nrow(hr_df), option = "D", direction = -1)
color_map <- setNames(viridis_colors, hr_ordered$group)
# Reorder the color map to match the factor levels for plotting
color_map <- color_map[group_levels]
# Prepare the legend labels with the calculated hazard ratios
legend_labels <- paste0(
group_levels,
" (HR: ",
round(hr_df$hazard_ratio, 2),
")"
)
# Create and return the plot
ggsurvplot(
fit,
data = lung,
palette = color_map,
risk.table = TRUE,
pval = TRUE,
legend.labs = legend_labels,
legend.title = paste(input$group_var, " (Reference:", group_levels[1], ")"),
title = "Kaplan-Meier Curves Shaded by Hazard Ratio",
subtitle = "Darker colors indicate a higher HR (steeper slope)"
)
})
}
# Run the application
shinyApp(ui = ui, server = server)
library(shiny)
library(survival)
library(survminer)
library(viridis)
# Load and prepare the data
data("lung")
lung <- na.omit(lung)
# Give factor levels clear names for the dropdown and plot
lung$sex <- factor(lung$sex, levels = c(1, 2), labels = c("Male", "Female"))
lung$ph.ecog <- factor(lung$ph.ecog, levels = c(0, 1, 2), labels = c("Good", "Moderate", "Poor"))
# Define UI for the application
ui <- fluidPage(
titlePanel("Kaplan-Meier Curves Shaded by Hazard Ratio"),
sidebarLayout(
sidebarPanel(
# Dropdown menu to select the grouping variable
selectInput(
inputId = "group_var",
label = "Select Grouping Variable:",
choices = c(
"Sex" = "sex",
"ECOG Performance Score" = "ph.ecog"
),
selected = "sex" # Default selected variable
),
helpText("The first level of the selected factor will be used as the reference group (HR = 1).",
"Curves are colored by their hazard ratio (HR) relative to this reference.",
"Darker colors represent a higher HR (steeper slope).")
),
mainPanel(
plotOutput("km_plot")
)
)
)
# Define server logic
server <- function(input, output) {
# Reactive expression to run the survival analysis
surv_analysis <- reactive({
# Ensure a grouping variable is selected
req(input$group_var)
# Dynamically create the formula for survfit and coxph
formula_surv <- as.formula(paste("Surv(time, status) ~", input$group_var))
# Create the survfit object
fit <- survfit(formula_surv, data = lung)
# Run the Cox Proportional Hazards model
cox_model <- coxph(formula_surv, data = lung)
# Return both objects
list(fit = fit, cox_model = cox_model)
})
# Reactive expression to handle the plotting
output$km_plot <- renderPlot({
# Get the results from the reactive analysis
analysis_results <- surv_analysis()
fit <- analysis_results$fit
cox_model <- analysis_results$cox_model
# Extract the hazard ratios and group labels dynamically
# THIS IS THE CRITICAL LINE THAT MUST USE [[ ]]
group_levels <- levels(lung[[input$group_var]])
# Create a data frame for hazard ratios, including the reference group
hr_values <- exp(coef(cox_model))
hr_df <- data.frame(
group = group_levels,
hazard_ratio = c(1.0, hr_values)
)
# Map hazard ratios to a viridis palette
# Order the ratios and create the color map
hr_ordered <- hr_df[order(hr_df$hazard_ratio), ]
viridis_colors <- viridis(n = nrow(hr_df), option = "D", direction = -1)
color_map <- setNames(viridis_colors, hr_ordered$group)
# Reorder the color map to match the factor levels for plotting
color_map <- color_map[group_levels]
# Prepare the legend labels with the calculated hazard ratios
legend_labels <- paste0(
group_levels,
" (HR: ",
round(hr_df$hazard_ratio, 2),
")"
)
# Create and return the plot
ggsurvplot(
fit,
data = lung,
palette = color_map,
risk.table = TRUE,
pval = TRUE,
legend.labs = legend_labels,
legend.title = paste(input$group_var, " (Reference:", group_levels[1], ")"),
title = "Kaplan-Meier Curves Shaded by Hazard Ratio",
subtitle = "Darker colors indicate a higher HR (steeper slope)"
)
})
}
# Run the application
shinyApp(ui = ui, server = server)
library(shiny)
library(survival)
library(survminer)
library(viridis)
# Load and prepare the data
data("lung")
lung <- na.omit(lung)
# Give factor levels clear names for the dropdown and plot
lung$sex <- factor(lung$sex, levels = c(1, 2), labels = c("Male", "Female"))
lung$ph.ecog <- factor(lung$ph.ecog, levels = c(0, 1, 2), labels = c("Good", "Moderate", "Poor"))
# Define UI for the application
ui <- fluidPage(
titlePanel("Kaplan-Meier Curves Shaded by Hazard Ratio"),
sidebarLayout(
sidebarPanel(
# Dropdown menu to select the grouping variable
selectInput(
inputId = "group_var",
label = "Select Grouping Variable:",
choices = c(
"Sex" = "sex",
"ECOG Performance Score" = "ph.ecog"
),
selected = "sex" # Default selected variable
),
helpText("The first level of the selected factor will be used as the reference group (HR = 1).",
"Curves are colored by their hazard ratio (HR) relative to this reference.",
"Darker colors represent a higher HR (steeper slope).")
),
mainPanel(
plotOutput("km_plot")
)
)
)
# Define server logic (FIXED)
server <- function(input, output) {
# Reactive expression to run the survival analysis
surv_analysis <- reactive({
# Ensure a grouping variable is selected
req(input$group_var)
# 1. Create a list of columns needed for the analysis
vars_to_check <- c("time", "status", input$group_var)
# 2. Filter out rows with NA values only in the required columns
cleaned_data <- lung[complete.cases(lung[, vars_to_check]), ]
# 3. Check if the cleaned data is empty
if (nrow(cleaned_data) == 0) {
# Stop the reactive expression and display a message if the data is empty
return(NULL)
}
# 4. Dynamically create the formula for survfit and coxph
formula_surv <- as.formula(paste("Surv(time, status) ~", input$group_var))
# 5. Create the survfit object using the cleaned data
fit <- survfit(formula_surv, data = cleaned_data)
# 6. Run the Cox Proportional Hazards model
cox_model <- coxph(formula_surv, data = cleaned_data)
# Return both objects and the cleaned data
list(fit = fit, cox_model = cox_model, cleaned_data = cleaned_data)
})
# Reactive expression to handle the plotting
output$km_plot <- renderPlot({
analysis_results <- surv_analysis()
# Check if the data was empty and stop the plot render if so
if (is.null(analysis_results)) {
showNotification("The selected data has no complete observations for analysis.", type = "error")
return(NULL)
}
# Get the results from the reactive analysis
fit <- analysis_results$fit
cox_model <- analysis_results$cox_model
cleaned_data <- analysis_results$cleaned_data
# Extract the hazard ratios and group labels dynamically
group_levels <- levels(cleaned_data[[input$group_var]])
# Create a data frame for hazard ratios, including the reference group
hr_values <- exp(coef(cox_model))
hr_df <- data.frame(
group = group_levels,
hazard_ratio = c(1.0, hr_values)
)
# Map hazard ratios to a viridis palette
hr_ordered <- hr_df[order(hr_df$hazard_ratio), ]
viridis_colors <- viridis(n = nrow(hr_df), option = "D", direction = -1)
color_map <- setNames(viridis_colors, hr_ordered$group)
# Reorder the color map to match the factor levels for plotting
color_map <- color_map[group_levels]
# Prepare the legend labels with the calculated hazard ratios
legend_labels <- paste0(
group_levels,
" (HR: ",
round(hr_df$hazard_ratio, 2),
")"
)
# Create and return the plot
ggsurvplot(
fit,
data = cleaned_data,
palette = color_map,
risk.table = TRUE,
pval = TRUE,
legend.labs = legend_labels,
legend.title = paste(input$group_var, " (Reference:", group_levels[1], ")"),
title = "Kaplan-Meier Curves Shaded by Hazard Ratio",
subtitle = "Darker colors indicate a higher HR (steeper slope)"
)
})
}
# Run the application
shinyApp(ui = ui, server = server)
### Ideas:
# Move search bar above rather than beside chart
# Rename chart axes
# Add explainer text
# Add slider chosing date ranges
# Adjust colors based on end time on x axis
# Share number of censored patients (those who never sang/did not sing in timeframe) (add to bottom graph?)
# # Load packages
pacman::p_load(
DBI, RSQLite, tidyverse, survival, survminer, plotly, shiny
)
# Connect to SQl Database
con = dbConnect(SQLite(), "minutes.db")
# Create table of all data tables
tables = as.data.frame(dbListTables(con))
# Query combing song data
sql_minutes = con %>% dbGetQuery(
"SELECT leader_id, song_id, minutes.id, minutes.date, songs.PageNum, songs.Title
FROM song_leader_joins
INNER JOIN songs ON song_leader_joins.song_id = songs.id
INNER JOIN minutes ON song_leader_joins.minutes_id = minutes.id
INNER JOIN minutes_location_joins ON minutes_location_joins.minutes_id = minutes.id")
## To fix, multi-day singing events
minutes = sql_minutes %>%
mutate(date = mdy(Date)) %>%
select(-c(Date)) %>%
drop_na()
# This is the date the person first led a specific song
first_sung_df = minutes %>%
group_by(leader_id, song_id,Title, PageNum) %>%
summarise(
date_first_sung = min(date),
.groups = 'drop'
)
# A person is "exposed" to a song on any date they were a leader at a meeting
# where that song was sung.
# First, get a list of all leaders who attended each meeting date
attendance_df = minutes %>%
distinct(date, id, leader_id)
# Next, get a list of all songs sung at each meeting date
songs_at_meeting_df = minutes %>%
distinct(date, id, song_id)
# Now, we join these two tables to find every possible leader-song-date combo
exposure_df = attendance_df %>%
inner_join(songs_at_meeting_df, by = "date") %>%
# Now, for each unique leader-song pair, find the first date
group_by(leader_id, song_id) %>%
summarise(
date_first_exposure = min(date),
.groups = 'drop'
)
# We use a full_join to keep all person-song combinations,
# including those who were exposed but never sang the song.
final_df = full_join(exposure_df,
first_sung_df,
by = c("leader_id", "song_id")) %>%
mutate(
# The date of first sung is not NA if the person actually sang the song
event_status = as.integer(!is.na(date_first_sung)),
# Calculate the time to event in days, only if the event occurred
time_to_event_days = case_when(
event_status == 1 ~ as.integer(date_first_sung - date_first_exposure),
TRUE ~ NA_integer_
)
) %>%
# Filter out combos which where time to event is zero, which means that
# a person sung a song at the first meeting which it was heard; likely
# meaning they otherwise heard the song beforehand
filter((time_to_event_days != 0 | is.na(time_to_event_days) == TRUE) & time_to_event_days <= 365) %>%
drop_na()
## For export and sheet analysis
survival_df = final_df %>%
select(song_id, event_status, time_to_event_days, Title, PageNum) %>%
write_csv("survival_analysis.csv")
### Shiny app
# Define UI for the application
ui <- fluidPage(
# Application title
titlePanel("Infectious Songs from the Sacred Harp"),
# Sidebar layout with a dropdown for song selection
sidebarLayout(
sidebarPanel(
selectizeInput(
inputId = "searchme",
label = "Search Bar",
multiple = TRUE,
# Choices will be populated by the server
choices = NULL,
options = list(
create = FALSE,
placeholder = "Search Me"
)
),
helpText("HELP TEXT HERE")
),
# Main panel for displaying the plot
mainPanel(
plotlyOutput("survival_plot")
)
)
)
# Server function
server <- function(input, output, session) {
# Get the unique names of the songs to populate the dropdown
song_choices_df = survival_df %>%
distinct(song_id, Title, PageNum) %>%
mutate(song_title = paste0(PageNum, " - ", Title)) %>%
arrange(song_id)
# The values will be the song_id, names will be the song_title
song_choices = setNames(song_choices_df$song_id, song_choices_df$song_title)
# Update the choices for the dropdown list
# This observe block will run once at startup to populate the choices.
observe({
updateSelectizeInput(
session,
"searchme",
choices = song_choices,
selected = NULL # No default selection for a clean start
)
})
# Reactive expression to filter the data based on user selection
filtered_data = reactive({
req(input$searchme)
# Filter the original data to include only the selected songs
df_filtered <- survival_df %>%
filter(song_id %in% input$searchme) %>%
# Create the 'song' column for the plot's strata
mutate(song = paste0(" ", PageNum, " - ", Title),
song = factor(song))
return(df_filtered)
})
# Generate and render the ggsurvplot
output$survival_plot <- renderPlotly({
# Get the filtered data
df = filtered_data()
fit = surv_fit(Surv(time_to_event_days, event_status) ~ song, data = df)
p = ggsurvplot(
fit,
data = df,
conf.int = TRUE,
risk.table = TRUE,
risk.table.col = "strata",
ggtheme = theme_bw(),
title = "Survival Curve by Song",
palette = "viridis"
)
# Convert the ggsurvplot ggplot object to an interactive plotly object.
# We pass p$plot, which is the main survival plot.
ggplotly(p$plot)
})
}
# Run the application
shinyApp(ui = ui, server = server)
usethis::use_github()
